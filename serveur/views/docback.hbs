<h1>{{title}}</h1>
<p>Ce petit serveur propose l'accès au jeu du Memory.</p>

<h2> Documentation partie serveur</h2>
<br />
<ul>
    <!--li> <h3> Page du jeux : </h3>
        <ul>
            <li>HTML5 : la structure est en HTML intégré dans un template Handlebars pour affichage données du classement</li>
            <li>CSS3 : Dans la mesure de mes connaissances, j'ai intégré Bootstrap pour la grille du jeux</li>
            <li>JS : Ecrit en grande partir en JavaScript Vanilla ES5. Utilisation de JQuery pour le tableau du classement (Datatable)</li>
        </ul>
    </li-->
    <li>
        <h3> Technologie Back-End : </h3>
        <ul>
            <li>Le moteur d'exécution est Node JS V v12.18.4</li>
            <ul>
                <li>Node JS est utilisé ici avec le module "Express" pour la gestion des requêtes HTTP et la gestion des
                    routes.</li>
                <li>Cependant, on utilise ici un framework <a
                        href="https://www.github.com/Stephanux/Minismall">"MiniSmall"</a> : pour simplifier le
                    développement et la maintenance</li>
            </ul>
            <li>La base de données est une MongoDB : mongodb version v3.6.9.
            <li>L'application charge le module Mongoose pour la connexion à la base NoSQL.</li>
        </ul>
    </li>
    <li>
        <h3> Voyons plus en détail le Framework MiniSmall </h3>
    </li>
    <ul>
        <li>Le principe de ce Framework est celui d'un automate fini. On pourrait le voir comme un Orgue de
            Barbarie.<br />
            En effet, nous avons un ensemble d'actions qui sont stockées dans un fichier JSON.<br />
            On l'appelle l'Annuaire des actions et le fichier se nomme "<b>routes/config_actions.json"</b>.
        </li>
        <li>Regardons l'arborescence du côté Back-End de notre projet de jeu Memory dans le dossier
            "serveur":<br /><br /><img src="/images/docback_arbo.png" alt="arborescence projet MiniSmall" /></li>
        <li>Nous allons également voir un schéma qui détaille une requête HTTP pour afficher l'écran du jeu de
            Memory.<br /><br /><img src="images/docback_http_request.png"
                alt="schéma d'une requête http dans l'application" /></li>
        <li>L'accès à la base de données se fait dans les fichiers "contrôleurs" qui se trouvent dans le répertoire
            routes.<br />
            Le principe du framework ici est de proposer des modules (classes) génériques qui réalise les princpaux
            accès à une base de données :</li>
        <ul>
            <li>La sélection de données (toutes ou filtrées)</li>
            <li>La mise à jour des données</li>
            <li>L'insertion de données</li>
            <li>La suppression de données</li>
        </ul>
        <li>Dans notre application de Memory, l'action du menu "Jeu Memory" est à l'origine d'une requête HTTP dont la
            méthode et "GET".<br />
            Et l'action, aussi appelé "pathname" est "/memory". Cela permet d'afficher l'interface du jeu où l'on peu
            sélectionner le<br />
            format de la grille de jeu. Mais elle affiche aussi le classement des scores par format de grille dans un
            tableau à droite.<br />
            Pour ce faire, il faut que l'on fasse une requête dans la base de données MongoDB et que l'on affiche les
            données sous la forme d'un<br />
            tableau.
        </li>
        <ul>
            <li>L'annuaire d'actions : routes/config_actions.json</li><br />
            <div id="editor1_wrapper" class="app_editor_wrapper">
                <div id="editor1" class="app_editor">{
    "GET/": {
        "controler": "getView",
        "view": "index",
        "title": "Bienvenue sur la page Recrutement formateur Full Stack pour O'Clock."
    },
    "GET/index": {
        "controler": "getView",
        "view": "index",
        "title": "Bienvenue sur la page Recrutement formateur Full Stack pour O'Clock."
    },
    "GET/memory": {
        "controler": "finder",
        "view": "memory",
        "modelName": "Memory",
        "sortfield": "score",
        "order": 0,
        "title": "It's thirteen O'Clock, time to make a MEMORY !"
    },
    "GET/setmemscore": {
        "controler": "insertOne",
        "modelName": "Memory",
        "view": "memory",
        "redirect": "/memory",
        "return_type": "application/json"
    },
    "GET/docihm": {
        "controler": "getView",
        "view": "docihm",
        "title": "Etude et analyse du code du jeu : l'IHM."
    },
    "GET/docback": {
        "controler": "getView",
        "view": "docback",
        "title": "Etude et analyse du code du jeu : Back-End."
    }
}
                </div>
                <div id="editor1_dragbar" class="app_editor_dragbar"></div>
            </div><br/>
            <li>On retrouve dans l'annuaire <b>"config_actions.json"</b> ci-dessus, le code qui permet de répondre à la requête HTTP <b>"GET/memory"</b>.<br/>
                On voit ici que le contrôleur (le fichier javascript du dossier "routes") défini pour répondre à la requête est <b>finder"</b>".<br/>
                On retrouve dans le dossier <b>"routes"</b> le fichier <b>"finder.js"</b> qui sera chargé et exécuté lorsque cette requête sera effectuée par un client.<br/><br/>
                <div id="editor2_wrapper" class="app_editor_wrapper">
                <div id="editor2" class="app_editor">
var express = require('express');
var router = express.Router();

/* GET users listing. */
router.get('/', function (req, res, next) {
    /*if ((req.session.passport) && (req.session.passport.user != null)) {*/
        if (global.actions_json[req.message.action].sortfield) var sortedfield = global.actions_json[req.message.action].sortfield;
        global.schemas[req.message.modelName].find({}).sort(sortedfield).lean().exec( function (err, result) {
            if (err) {
                throw err;
            }
            console.log("connexion depuis Finder : ", result);
            if (req.message.return_type == null) {
                res.render(req.message.view, {
                    stitle: 'First Cnx Mongo',
                    title: req.message.title,
                    libelle: req.message.libelle,
                    del_label: req.message.del_label,
                    form_action: req.message.form_action,
                    data: result  // Attention a renvoyer une variable avec un nom generique
                });
                //}

            } else {
                res.setHeader('content-type', 'application/json');
                res.send(result);
            }
        });
  /*  } else {
        res.redirect('/');  // affichage boîte de login si pas authentifié
    }*/
});

module.exports = router;
                </div>
                <div id="editor2_dragbar" class="app_editor_dragbar"></div>
            </div><br/>
            </li>
            <li>Voici un extrait de code du contrôleur <b>"finder.js"</b> et plus particulièrement la fonction get(...) qui répond à la demande <b>"GET/memory"</b>.<br/>
                La ligne important ici pour l'exécution de la requête est : <br/><br/>
                <pre><b>global.schemas[req.message.modelName].find({}).sort(sortedfield).lean().exec( function (err, result) { ...</b></pre><br/>
                Ici on récupère l'instance du schéma <b>"Mongoose"</b> stocké dans le fichier <b>"database_schema.json"</b>, fichier lu au démarrage de l'application dans le fichier <b>"appdyn.js"</b>.<br/>
                Un extrait du fichier de description des collections de la base de données : <br/>
                <div id="editor3_wrapper" class="app_editor_wrapper">
                <div id="editor3" class="app_editor">
{
	"Countries" : {
		"collection" : "countries",
		"schema": {
        	"_id": "ObjectId",
	    	"code": "String",
	    	"name": "String"
    	}
    },
    "Memory": {
        "collection": "memory",
        "schema": {
            "_id": "ObjectId",
            "nickname": "String",
            "format": "String",
            "score": "Number"
        }
    },
    "Users": {
        "collection": "users",
        "schema": {
            "_id": "ObjectId",
            "name": "String",
            "firstName": "String",
            "login": "String",
            "mdp": "String",
            "function": "String",
            "office": "String",
            "date_naiss": "String",
            "adresse1": "String",
            "adresse2": "String",
            "cp": "String",
            "city": "String",
            "country": {
                "type": "ObjectId",
                "ref": "Countries"
            },
            "mobile_phone": "String",
            "home_phone": "String"
        }
    }
}
                </div>
                <div id="editor3_dragbar" class="app_editor_dragbar"></div>
            </div><br/>
            </li>

       </ul>
    </ul>
</ul>

<script>

var aceEditorInstance = ace.edit( "editor1" );
aceEditorInstance.setReadOnly(true)
aceEditorInstance.setTheme("ace/theme/dracula");
aceEditorInstance.getSession().setMode( { path: "ace/mode/json", inline: true } );

var aceEditorInstance2 = ace.edit( "editor2" );
aceEditorInstance2.setReadOnly(true)
aceEditorInstance2.setTheme("ace/theme/dracula");
aceEditorInstance2.getSession().setMode( { path: "ace/mode/javascript", inline: true } );

var aceEditorInstance = ace.edit( "editor3" );
aceEditorInstance.setReadOnly(true)
aceEditorInstance.setTheme("ace/theme/dracula");
aceEditorInstance.getSession().setMode( { path: "ace/mode/json", inline: true } );

makeAceEditorResizable(aceEditorInstance);
makeAceEditorResizable(aceEditorInstance2);
makeAceEditorResizable(aceEditorInstance3);

</script>
<!--img src="images/docback.png" /-->